/**
 * Definition for an interval.
 * struct Interval {
 *     int start;
 *     int end;
 *     Interval() : start(0), end(0) {}
 *     Interval(int s, int e) : start(s), end(e) {}
 * };
 */
class Solution {
public:
	bool judge(int a, int b, int type){
		if(type == 0){
			return a <= b;
		}else{
			return a >= b;
		}
	}
	int find(vector<Interval> &intervals, int val, int type){
		int l = 0, r = intervals.size() - 1;
		int m;
		int loc = -1;
		while(l <= r){
			m = l + (r - l)/2;
			if(judge(intervals[m].start, val, type)){
				loc = m;
				if(type == 1){
					r = m - 1;
				}else{
					l = m + 1;
				}
			}else{
				if(type == 1){
					l = m +ã€€1;
				}else{
					r = m - 1;
				}
			}
		}
		
		return loc;
	}
    vector<Interval> insert(vector<Interval> &intervals, Interval newInterval) {
        // Start typing your C/C++ solution below
        // DO NOT write int main() function
        vector<Interval> ans;
		int n = intervals.size();
		if(n == 0){
			ans.push_back(newInterval);
			return ans;
		}
		
		int l = find(intervals, newInterval.start, 0);
		int r = find(intervals, newInterval.end, 1);
		Interval now = newsInterval;
		if(l > 0 && intervals[l - 1].end >= newsInterval.start){
			now.start = intervals[l - 1].start;
			l--;
		}
		
		if(r < n - 1 && intervals[r + 1].start <= newsInterval.end){
			now.end = interval[r + 1].end;
			r++;
		}
		
		for(int i = 0; i < l; i++){
			ans.push_back(intervals[i]);
		}
		ans.push_back(now);
		for(int i = r; i < n; i++){
			ans.push_back(intervals[i]);
		}
		
		return ans;
		
    }
};
